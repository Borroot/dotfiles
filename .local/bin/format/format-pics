#!/usr/bin/env bash
# AUTHOR: Bram Pulles

# This program formats all the images in the $DIR folder
# to one unified format.

readonly DIR=$HOME/Nextcloud/photos/archive
readonly FORMATS=./formats

readonly TMP_IN=$(mktemp)
readonly TMP_OUT=$(mktemp)

# Remove all the temporaray files.
cleanup ()
{
	rm -f "$TMP_IN" "$TMP_OUT"
}

# Convert all of the matching formats to the unified format.
format ()
{
	ls "$DIR" > "$TMP_IN"
	sed -nE -f "$FORMATS" < "$TMP_IN" > "$TMP_OUT"
}

# Count how many files came in and how many files are converted.
# Also count how many of the converted files are unique.
count ()
{
	num_in=$(wc -l < "$TMP_IN")
	num_out=$(wc -l < "$TMP_OUT")
	num_uniq=$(sed -E 's/(".+"|.+) (.+)/\2/g' < "$TMP_OUT" \
	         | sort | uniq | wc -l)
}

# Increase the last six digits of the dest variable by one.
inc_dest ()
{
	local six
	six=$(sed -E 's/.*-.*-.*-([[:digit:]]{6})\..*/\1/g' <<< "$dest")

	six=$(sed 's/^0*//g' <<< "$six")   # remove leading zero's
	((six++))                          # increase by one
	six=$(printf '%06i' "$six")        # add leading zero's

	dest=$(sed -E 's/(.*-.*-.*-).*\.(.*)/\1'"$six"'.\2/g' <<< "$dest")
}

# Not all of the files in the new format are unique, this means that
# those files have to be made unique in some way to prevent data loss.
uniqueify ()
{
	((num_out == num_uniq)) && return

	>&2 echo -e "The following files map to the same dest:\n"

	# Loop over all the dests which are not unique. For every
	# dest take all the mappings corresponding to this dest
	# and change them until they are all unique.
	sed -E 's/(".+"|.+) (.+)/\2/g' < "$TMP_OUT" | sort | uniq -dc |
	while read -r num_dest
	do
		local num dest original # num of occurences of dest
		num=$(     cut -d ' ' -f 1 <<< "$num_dest") # >= 2
		dest=$(cut -d ' ' -f 2 <<< "$num_dest") && original="$dest"

		# Print the mappings which are not unique.
		>&2 echo "  Conflicting mappings:"
		grep -F "$dest" < "$TMP_OUT" | sed -E 's/(.*) (.*)/    \1\t-> \2/g' >&2
		>&2 echo "  Automatically resolve:"

		for ((i = 2; i <= num; i++))
		do
			# Increase the destinations until is is unique.
			inc_dest
			while grep -q "$dest" < "$TMP_OUT"
			do
				inc_dest
			done

			# Replace the dest at the line number found, this is the i'th dest.
			# The i'th dest is found with 'grep -m $i'.
			local dest_line dest_linenr
			dest_line=$(grep --line-number -m "$i" "$original" < "$TMP_OUT" | tail -n 1)
			dest_linenr=$(sed -E 's/^([[:digit:]]+):.*/\1/' <<< "$dest_line")

			sed -i "${dest_linenr}s/$original/$dest/" "$TMP_OUT"

			# Print how the conflict is solved.
			local line src
			line=$(grep -F "$dest" < "$TMP_OUT")
			src=$(sed -E "s/(\".+\"|.+) .+/\\1/" <<< "$line")
			>&2 echo -e "    $src\t-> $dest\n"
		done
	done
}

# Prompt to ask for verification of the user.
verify ()
{
	less < "$TMP_OUT" && echo -n "Please verify if this is correct [no/yes]: "
	read -r answer

	if [[ "$answer" != yes ]]
	then
		cleanup
		exit 1
	fi
}

# Convert the files from the old format to the new format by simply
# renaming them using 'mv'.
convert ()
{
	while read -r line
	do
		local src dest
		src=$( sed -E 's/(".+"|.+) (.+)/\1/g' <<< "$line")
		dest=$(sed -E 's/(".+"|.+) (.+)/\2/g' <<< "$line")
		# TODO do the actual 'mv' command
		echo "mv $src -> $dest"
	done < "$TMP_OUT"

	echo "Replaced $num_out out of $num_in."
}

# Print all the files which are not converted and thus not matched
# with any of the formats in the $FORMATS file.
not_converted ()
{
	local formats_or
	# Create a regex from the $FORMATS file for grep, the inverted
	# matched files are all files which are not converted.
	formats_or=$(sed -nE 's;s/(.*)/.*/gp;(\1);p' < formats \
	            | tr '\n' '|' | sed -E 's/(.*)\|/\1/g')
	>&2 echo "These files cannot be matched against any pattern in $FORMATS."
	grep -vE "$formats_or" < "$TMP_IN" | sed 's/.*/    &/g' >&2
}

main ()
{
	format
	count
	uniqueify
	verify
	convert
	not_converted
	cleanup
}

main "$@"
